// This package exists purely for the convenience of easily running tests which
// test the offline functionality of the graph package.
// `unshare -nr` is used to deny network access, and then the tests are run using
// cached data from the tests in the graph package.
package offline

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/jstaf/onedriver/fs"
	"github.com/stretchr/testify/require"
)

// TestOfflineReaddir verifies that we can read directory contents in offline mode
func TestOfflineReaddir(t *testing.T) {
	t.Parallel()

	// Read the test directory
	files, err := os.ReadDir(TestDir)
	require.NoError(t, err, "Failed to read test directory %s in offline mode", TestDir)

	// Verify that the directory is not empty
	require.Greater(t, len(files), 0,
		"Expected more than 0 files in the test directory %s when in offline mode", TestDir)
}

// TestOfflineBagelDetection verifies that we can find and access the "bagels" file in offline mode
func TestOfflineBagelDetection(t *testing.T) {
	// Not running in parallel to ensure this test runs after the file is fully created

	// Read the test directory
	files, err := os.ReadDir(TestDir)
	require.NoError(t, err, "Failed to read test directory %s in offline mode", TestDir)

	// Collect all file names for better error reporting
	found := false
	allFiles := make([]string, 0, len(files))

	// Look for the "bagels" file
	for _, f := range files {
		allFiles = append(allFiles, f.Name())

		if f.Name() == "bagels" {
			found = true

			// Verify it's a regular file, not a directory
			require.False(t, f.IsDir(),
				"\"bagels\" should be an ordinary file, not a directory")

			// Check file permissions
			info, err := f.Info()
			require.NoError(t, err, "Failed to get file info for \"bagels\"")

			octal := fs.Octal(uint32(info.Mode().Perm()))
			// middle bit just needs to be higher than 4
			// for compatibility with 022 / 002 umasks on different distros
			require.True(t, octal[0] == '6' && int(octal[1])-4 >= 0 && octal[2] == '4',
				"\"bagels\" permissions bits wrong, got %s, expected 644", octal)

			break
		}
	}

	// Verify the file was found
	require.True(t, found,
		"\"bagels\" file not found in offline mode! Available files: %v", allFiles)
}

// Does the contents of the bagels file match what it should?
// (File contents generated by TestEchoWritesToFile in previous tests.)
func TestOfflineBagelContents(t *testing.T) {
	// Not running in parallel to ensure this test runs before TestOfflineFileModification
	bagelPath := filepath.Join(TestDir, "bagels")
	contents, err := os.ReadFile(bagelPath)
	require.NoError(t, err, "Failed to read bagels file at %s in offline mode", bagelPath)

	expectedContent := []byte("bagels\n")
	require.Equal(t, expectedContent, contents, 
		"Offline file contents did not match expected content. Got %q, expected %q", 
		string(contents), string(expectedContent))
}

// Creating a file should succeed in offline mode
func TestOfflineFileCreation(t *testing.T) {
	t.Parallel()
	donutsPath := filepath.Join(TestDir, "donuts")
	donutsContent := []byte("donuts are tasty")

	// Setup cleanup to run after test completes or fails
	t.Cleanup(func() {
		if err := os.Remove(donutsPath); err != nil && !os.IsNotExist(err) {
			t.Logf("Warning: Failed to clean up test file %s: %v", donutsPath, err)
		}
	})

	// Write the file in offline mode
	err := os.WriteFile(donutsPath, donutsContent, 0644)
	require.NoError(t, err, "Writing a file while offline should succeed")

	// Verify the file was created and has the correct content
	contents, err := os.ReadFile(donutsPath)
	require.NoError(t, err, "Reading the file should succeed")
	require.Equal(t, donutsContent, contents, "File contents should match what was written")
}

// Modifying a file offline should succeed
func TestOfflineFileModification(t *testing.T) {
	t.Parallel()
	bagelPath := filepath.Join(TestDir, "bagels")
	newContent := []byte("modified bagels are better")

	// First read the original content
	originalContent, err := os.ReadFile(bagelPath)
	require.NoError(t, err, "Failed to read original content from %s in offline mode", bagelPath)

	// Setup cleanup to restore the original content after test completes or fails
	t.Cleanup(func() {
		if err := os.WriteFile(bagelPath, originalContent, 0644); err != nil {
			t.Logf("Warning: Failed to restore original content to %s: %v", bagelPath, err)
		}
	})

	// Modify the file in offline mode
	err = os.WriteFile(bagelPath, newContent, 0644)
	require.NoError(t, err, "Failed to modify file %s in offline mode", bagelPath)

	// Verify the file was modified and has the new content
	modifiedContent, err := os.ReadFile(bagelPath)
	require.NoError(t, err, "Failed to read modified content from %s in offline mode", bagelPath)

	require.Equal(t, newContent, modifiedContent, 
		"File contents after modification did not match expected content. Got %q, expected %q", 
		string(modifiedContent), string(newContent))

	require.NotEqual(t, originalContent, modifiedContent, 
		"File contents were not changed after modification. Content is still %q", 
		string(modifiedContent))
}

// Deleting a file offline should succeed
func TestOfflineFileDeletion(t *testing.T) {
	t.Parallel()

	// Create a test file to delete
	testFilePath := filepath.Join(TestDir, "file_to_delete.txt")
	testContent := []byte("this file will be deleted")
	err := os.WriteFile(testFilePath, testContent, 0644)
	require.NoError(t, err, "Failed to create test file %s in offline mode", testFilePath)

	// Setup cleanup to ensure the file is removed even if the test fails before deletion
	t.Cleanup(func() {
		if err := os.Remove(testFilePath); err != nil && !os.IsNotExist(err) {
			t.Logf("Warning: Failed to clean up test file %s: %v", testFilePath, err)
		}
	})

	// Verify the file exists
	_, err = os.Stat(testFilePath)
	require.NoError(t, err, "Test file %s should exist before deletion but was not found", testFilePath)

	// Delete the file in offline mode
	err = os.Remove(testFilePath)
	require.NoError(t, err, "Failed to delete file %s in offline mode", testFilePath)

	// Verify the file was deleted
	_, err = os.Stat(testFilePath)
	require.Error(t, err, "Test file %s should not exist after deletion but was found", testFilePath)
	require.True(t, os.IsNotExist(err), 
		"Error for deleted file %s should be 'file does not exist', but got: %v", 
		testFilePath, err)
}

// Creating a directory offline should succeed
func TestOfflineMkdir(t *testing.T) {
	t.Parallel()
	dirPath := filepath.Join(TestDir, "offline_dir")

	// Setup cleanup to remove the directory after test completes or fails
	t.Cleanup(func() {
		if err := os.RemoveAll(dirPath); err != nil {
			t.Logf("Warning: Failed to clean up test directory %s: %v", dirPath, err)
		}
	})

	// Create the directory in offline mode
	err := os.Mkdir(dirPath, 0755)
	require.NoError(t, err, "Failed to create directory %s in offline mode", dirPath)

	// Verify the directory was created
	info, err := os.Stat(dirPath)
	require.NoError(t, err, "Directory %s should exist after creation but was not found", dirPath)
	require.True(t, info.IsDir(), 
		"Path %s should be a directory but has file mode %s", 
		dirPath, info.Mode().String())
}

// Deleting a directory offline should succeed
func TestOfflineRmdir(t *testing.T) {
	t.Parallel()

	// Create a test directory to delete
	dirPath := filepath.Join(TestDir, "dir_to_delete")
	err := os.Mkdir(dirPath, 0755)
	require.NoError(t, err, "Failed to create test directory %s in offline mode", dirPath)

	// Setup cleanup to ensure the directory is removed even if the test fails before deletion
	t.Cleanup(func() {
		if err := os.RemoveAll(dirPath); err != nil && !os.IsNotExist(err) {
			t.Logf("Warning: Failed to clean up test directory %s: %v", dirPath, err)
		}
	})

	// Verify the directory exists
	_, err = os.Stat(dirPath)
	require.NoError(t, err, "Test directory %s should exist before deletion but was not found", dirPath)

	// Delete the directory in offline mode
	err = os.Remove(dirPath)
	require.NoError(t, err, "Failed to delete directory %s in offline mode", dirPath)

	// Verify the directory was deleted
	_, err = os.Stat(dirPath)
	require.Error(t, err, "Test directory %s should not exist after deletion but was found", dirPath)
	require.True(t, os.IsNotExist(err), 
		"Error for deleted directory %s should be 'file does not exist', but got: %v", 
		dirPath, err)
}

// Test that changes made in offline mode are cached and marked as changed
func TestOfflineChangesCached(t *testing.T) {
	t.Parallel()

	// Create a test file in offline mode
	testFilePath := filepath.Join(TestDir, "cached_changes.txt")
	testContent := []byte("this file was created in offline mode")

	// Setup cleanup to remove the test file after test completes or fails
	t.Cleanup(func() {
		if err := os.Remove(testFilePath); err != nil && !os.IsNotExist(err) {
			t.Logf("Warning: Failed to clean up test file %s: %v", testFilePath, err)
		}
	})

	err := os.WriteFile(testFilePath, testContent, 0644)
	require.NoError(t, err, "Failed to create file %s in offline mode", testFilePath)

	// Verify the file exists and has the correct content
	content, err := os.ReadFile(testFilePath)
	require.NoError(t, err, "Failed to read content from file %s in offline mode", testFilePath)
	require.Equal(t, testContent, content, 
		"File content in %s did not match what was written. Got %q, expected %q", 
		testFilePath, string(content), string(testContent))

	// The file should be marked as changed in the filesystem
	// Note: We can't directly access the filesystem's internal state from these tests,
	// but the fact that we can read the file back confirms it was cached locally
}

// Test that when going back online, files are synchronized
func TestOfflineSynchronization(t *testing.T) {
	// This test is not run in parallel because it changes the global offline state

	// Create a test file in offline mode
	syncFilePath := filepath.Join(TestDir, "sync_test.txt")
	syncContent := []byte("this file will be synchronized when online")

	// Setup cleanup to remove the test file after test completes or fails
	t.Cleanup(func() {
		if err := os.Remove(syncFilePath); err != nil && !os.IsNotExist(err) {
			t.Logf("Warning: Failed to clean up test file %s: %v", syncFilePath, err)
		}
	})

	err := os.WriteFile(syncFilePath, syncContent, 0644)
	require.NoError(t, err, "Failed to create file %s in offline mode", syncFilePath)

	// Verify the file exists and has the correct content
	content, err := os.ReadFile(syncFilePath)
	require.NoError(t, err, "Failed to read content from file %s in offline mode", syncFilePath)
	require.Equal(t, syncContent, content, 
		"File content in %s did not match what was written. Got %q, expected %q", 
		syncFilePath, string(content), string(syncContent))

	// Note: We can't actually test the synchronization in this test suite because:
	// 1. We're running with network access disabled via unshare
	// 2. We don't have access to the filesystem's internal state
	//
	// In a real scenario, when the filesystem goes back online:
	// 1. The changes would be detected as they're marked in the local cache
	// 2. The upload manager would process the queued changes
	// 3. The files would be synchronized with OneDrive
}
